================================================================================
                    TILED BACKGROUND RENDERER SETUP GUIDE
                              NDS Tetris Project
================================================================================

This guide walks you through setting up a tile-based renderer for both screens.
Tiled backgrounds are perfect for Tetris since the game is already grid-based.

================================================================================
PART 1: UNDERSTANDING NDS TILED BACKGROUNDS
================================================================================

The NDS has two engines:
    - Main engine (can be top or bottom screen)
    - Sub engine (the other screen)

Each engine can display up to 4 background layers (BG0-BG3).

A tiled background consists of:
    1. TILES (8x8 pixel graphics stored in VRAM)
    2. MAP (grid that says which tile goes where)
    3. PALETTE (colors the tiles use)

Think of it like this:
    - Tiles are your "stamp collection" (the different block colors, empty cell, etc.)
    - Map is your canvas where you place stamps
    - Palette defines what colors those stamps use

For Tetris:
    - You might have tiles for: empty cell, I-block color, O-block color, etc.
    - The map is your 10x20 playfield (plus borders, UI elements)
    - Each tile index in the map references one of your tile graphics

================================================================================
PART 2: VRAM BANKS
================================================================================

NDS has multiple VRAM banks (A, B, C, D, E, F, G, H, I) that you assign to
different purposes. For tiled backgrounds:

Main engine backgrounds can use:
    - VRAM_A, VRAM_B, VRAM_C, VRAM_D, VRAM_E, VRAM_F, VRAM_G

Sub engine backgrounds can use:
    - VRAM_C (as VRAM_C_SUB_BG)
    - VRAM_H (as VRAM_H_SUB_BG)

Common setup for two-screen tiled game:
    vramSetBankA(VRAM_A_MAIN_BG);      // Main engine BG tiles & map
    vramSetBankC(VRAM_C_SUB_BG);       // Sub engine BG tiles & map

================================================================================
PART 3: VIDEO MODE SETUP
================================================================================

For tiled backgrounds, use MODE_0_2D through MODE_5_2D.
MODE_0_2D is simplest - all 4 BGs are regular tiled backgrounds.

Main engine:
    videoSetMode(MODE_0_2D | DISPLAY_BG0_ACTIVE);

Sub engine:
    videoSetModeSub(MODE_0_2D | DISPLAY_BG0_ACTIVE);

You can enable multiple BGs:
    videoSetMode(MODE_0_2D | DISPLAY_BG0_ACTIVE | DISPLAY_BG1_ACTIVE);

================================================================================
PART 4: BACKGROUND CONTROL
================================================================================

Each BG needs to be configured. Use bgInit() for main or bgInitSub() for sub:

    int bgId = bgInit(
        0,                  // BG number (0-3)
        BgType_Text8bpp,    // Type: Text8bpp for 256-color tiles
        BgSize_T_256x256,   // Size: 256x256 pixels (32x32 tiles)
        0,                  // Map base (which 2KB block for map data)
        1                   // Tile base (which 16KB block for tile data)
    );

For sub engine:
    int bgId = bgInitSub(0, BgType_Text8bpp, BgSize_T_256x256, 0, 1);

IMPORTANT - Map base and tile base:
    - Map base: each unit = 2KB offset in VRAM
    - Tile base: each unit = 16KB offset in VRAM
    - Make sure they don't overlap!

Common setup (map at base 0, tiles at base 1):
    - Map uses VRAM offset 0 (base 0 * 2KB = 0)
    - Tiles use VRAM offset 16KB (base 1 * 16KB = 16384)
    - They don't overlap, you're good

================================================================================
PART 5: GETTING VRAM POINTERS
================================================================================

After bgInit(), you need pointers to write tile and map data:

    // Get pointer to map (where you write tile indices)
    u16* mapPtr = bgGetMapPtr(bgId);

    // Get pointer to tile graphics
    u16* tilePtr = bgGetGfxPtr(bgId);

Store these in your Renderer class as member variables.

================================================================================
PART 6: SETTING UP TILES
================================================================================

For 8bpp (256 color) tiles, each tile is 64 bytes (8x8 pixels, 1 byte per pixel).

Each byte is a palette index (0-255).

To create a solid colored tile programmatically:

    // Assuming tilePtr points to tile VRAM
    // Tile 0 = empty (color 0)
    // Tile 1 = solid color 1
    // Tile 2 = solid color 2
    // etc.

    u8* tiles = (u8*)tilePtr;

    // Fill tile 1 with palette color 1 (64 bytes per tile)
    for(int i = 0; i < 64; i++) {
        tiles[64 * 1 + i] = 1;  // palette index 1
    }

    // Fill tile 2 with palette color 2
    for(int i = 0; i < 64; i++) {
        tiles[64 * 2 + i] = 2;  // palette index 2
    }

Or use memset:
    memset(&tiles[64 * 1], 1, 64);  // tile 1 = color 1
    memset(&tiles[64 * 2], 2, 64);  // tile 2 = color 2

================================================================================
PART 7: SETTING UP PALETTE
================================================================================

For main engine BG:
    BG_PALETTE[0] = RGB15(0, 0, 0);      // Color 0: black (background)
    BG_PALETTE[1] = RGB15(0, 31, 31);    // Color 1: cyan (I-block)
    BG_PALETTE[2] = RGB15(31, 31, 0);    // Color 2: yellow (O-block)
    BG_PALETTE[3] = RGB15(31, 0, 31);    // Color 3: purple (T-block)
    // ... etc for each tetromino color

For sub engine BG:
    BG_PALETTE_SUB[0] = RGB15(0, 0, 0);
    BG_PALETTE_SUB[1] = RGB15(0, 31, 31);
    // ... etc

RGB15(r, g, b) takes values 0-31 for each channel.

================================================================================
PART 8: DRAWING TO THE MAP
================================================================================

The map is a grid of 16-bit entries. For basic usage, each entry is just the
tile index (0-1023 for text BGs).

Map size 256x256 = 32x32 tiles = 1024 entries.

To set a tile at position (x, y):

    mapPtr[y * 32 + x] = tileIndex;

Example - draw a cyan block at grid position (5, 10):

    mapPtr[10 * 32 + 5] = 1;  // tile 1 = cyan

To clear a cell:

    mapPtr[10 * 32 + 5] = 0;  // tile 0 = empty/background

================================================================================
PART 9: YOUR RENDERER CLASS STRUCTURE
================================================================================

Based on all this, your Renderer class should have:

MEMBER VARIABLES:
    int m_screen;           // which screen (GAME_SCREEN or UI_SCREEN)
    int m_bgId;             // background ID returned by bgInit
    u16* m_mapPtr;          // pointer to map data
    u16* m_tilePtr;         // pointer to tile graphics

METHODS:
    void initialize(int screen, int mode);
        - Set video mode (videoSetMode or videoSetModeSub based on screen)
        - Set VRAM bank (vramSetBankA or vramSetBankC based on screen)
        - Initialize BG (bgInit or bgInitSub based on screen)
        - Get and store map/tile pointers
        - Set up tiles (create your solid color tiles)
        - Set up palette

    void setTile(int x, int y, int tileIndex);
        - Write to map: m_mapPtr[y * 32 + x] = tileIndex;

    void clear();
        - Fill entire map with tile 0 (or use memset)

    void clearRect(int x, int y, int width, int height);
        - Clear a rectangular region

================================================================================
PART 10: INITIALIZATION ORDER IN RENDERER::INITIALIZE()
================================================================================

Here's the order of operations:

1. Determine if main or sub engine based on screen parameter

2. Set video mode:
    if main: videoSetMode(mode | DISPLAY_BG0_ACTIVE);
    if sub:  videoSetModeSub(mode | DISPLAY_BG0_ACTIVE);

3. Set VRAM bank:
    if main: vramSetBankA(VRAM_A_MAIN_BG);
    if sub:  vramSetBankC(VRAM_C_SUB_BG);

4. Initialize background:
    if main: m_bgId = bgInit(0, BgType_Text8bpp, BgSize_T_256x256, 0, 1);
    if sub:  m_bgId = bgInitSub(0, BgType_Text8bpp, BgSize_T_256x256, 0, 1);

5. Get pointers:
    m_mapPtr = bgGetMapPtr(m_bgId);
    m_tilePtr = bgGetGfxPtr(m_bgId);

6. Create tiles (solid colored blocks for each tetromino type)

7. Set up palette colors

8. Clear the map (fill with tile 0)

================================================================================
PART 11: TETRIS-SPECIFIC TILE SETUP
================================================================================

For Tetris you probably want these tiles:
    Tile 0: Empty cell (transparent or dark background)
    Tile 1: I-block color (cyan)
    Tile 2: O-block color (yellow)
    Tile 3: T-block color (purple)
    Tile 4: S-block color (green)
    Tile 5: Z-block color (red)
    Tile 6: J-block color (blue)
    Tile 7: L-block color (orange)
    Tile 8: Border/wall
    Tile 9: Ghost piece (semi-transparent or gray)

Match these with palette entries:
    Palette 0: Black/transparent
    Palette 1: Cyan      RGB15(0, 31, 31)
    Palette 2: Yellow    RGB15(31, 31, 0)
    Palette 3: Purple    RGB15(31, 0, 31)
    Palette 4: Green     RGB15(0, 31, 0)
    Palette 5: Red       RGB15(31, 0, 0)
    Palette 6: Blue      RGB15(0, 0, 31)
    Palette 7: Orange    RGB15(31, 16, 0)
    Palette 8: Gray      RGB15(16, 16, 16)
    Palette 9: Dark gray RGB15(8, 8, 8)

================================================================================
PART 12: DON'T FORGET
================================================================================

- Include <nds.h> in your renderer.cpp
- Store m_screen in initialize() so other methods know which screen they're on
- The NDS screen is 256x192 pixels = 32x24 tiles
- Tetris playfield (10x20) fits nicely, leaves room for borders and UI
- Call swiWaitForVBlank() in your game loop to sync with display refresh

================================================================================
SUMMARY CHECKLIST
================================================================================

[ ] Add member variables to Renderer class (m_screen, m_bgId, m_mapPtr, m_tilePtr)
[ ] Include <nds.h> in renderer.cpp
[ ] In initialize(): check screen and call correct videoSetMode/videoSetModeSub
[ ] In initialize(): set correct VRAM bank
[ ] In initialize(): call bgInit or bgInitSub
[ ] In initialize(): get map and tile pointers with bgGetMapPtr/bgGetGfxPtr
[ ] In initialize(): create solid color tiles for each block type
[ ] In initialize(): set up palette colors
[ ] In initialize(): clear the map
[ ] Add setTile(x, y, tileIndex) method
[ ] Add clear() method
[ ] Update constants.hpp with tile indices if you want named constants

================================================================================
